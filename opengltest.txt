from tkinter import *
import tkviewport
from OpenGL.GL import *
import array
import ctypes
from ctypes import c_void_p

from OpenGL.GL.ARB.vertex_array_object import glBindVertexArray

import numpy
null = c_void_p(0)

from OpenGL.arrays import vbo



class Renderer(tkviewport.OpenGLFrame):
    vertex = """
    #version 330 core
    layout(location=0) in vec3 vertexPosition_modelspace

    void main(){
        gl_Position.xyz=vertexPosition_modelspace;
        gl_position.w=1.0;
    }
"""
    fragment='''
    #version 330 core
    out vec3 color;
    void main(){
    color=vec3(1,0,0);
    }
'''
    
    def LoadShaders(self,vertex,fragment):
        vertexShaderID = glCreateShader(GL_VERTEX_SHADER)
        fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER)

        result = GL_FALSE
        print("Compiling vertex shader...")

        charArray = ([char for char in vertex])
        
        glShaderSource( vertexShaderID,charArray,None)
        glCompileShader(vertex)

        result = glGetShaderiv(vertexShaderID,GL_COMPILE_STATUS)
        
        infoLogLength = glGetShaderiv(vertexShaderID,GL_INFO_LOG_LENGTH)
        if infoLogLength > 0:
            VertexShaderErrorMessage = glGetShaderInfoLog(vertexShaderID, infoLogLength)
            print(VertexShaderErrorMessage)

        print("Compiling fragment shader...")
        glShaderSource( fragmentShaderID,vertex)
        glCompileShader(fragment)

        result = glGetShaderiv(fragmentShaderID,GL_COMPILE_STATUS)
        infoLogLength = glGetShaderiv(fragmentShaderID,GL_INFO_LOG_LENGTH)
        if infoLogLength > 0:
            fragmentShaderErrorMessage = glGetShaderInfoLog(fragmentShaderID, infoLogLength)
            print(fragmentShaderErrorMessage)
	    
        print("Linking Program")
        ProgramID = glCreateProgram()
        glAttachShader(ProgramID, VertexShaderID)
        glAttachShader(ProgramID, FragmentShaderID)
        glLinkProgram(ProgramID)

	#Check the program
        result=glGetProgramiv(ProgramID, GL_LINK_STATUS)
        InfoLogLength=glGetProgramiv(ProgramID, GL_INFO_LOG_LENGTH)
        if ( InfoLogLength > 0 ):
            ProgramErrorMessage= glGetProgramInfoLog(ProgramID, InfoLogLength, NULL)
            print(ProgramErrorMessage)
	
	
        glDetachShader(ProgramID, vertexShaderID)
        glDetachShader(ProgramID, fragmentShaderID)
	
        glDeleteShader(vertexShaderID)
        glDeleteShader(fragmentShaderID)

        return ProgramID

    def GetMachingCases(self):
        weights = [
            [1,1,1,1],
            [1,0,0,1],
            [1,0,0,1],
            [1,1,1,1]]
        cases = list([[0 for x in range(len(weights[y]))] for y in range(len(weights)) ])
        yLength = len(weights)
        xLength = len(weights[0])
        for y in range(yLength):
            for x in range(xLength):
                for offset in ((-1,-1,1),(-1,1,8),(1,-1,2),(1,1,4)):
                    offx = x + offset[0]
                    offy = y + offset[1]
                    if offx >= 0 and offy >= 0 and offx < xLength and offy < yLength:
                        if weights[offy][offx] == 1:
                            cases[x][y]+=offset[2]
                    else:#point is outside range of grid
                        cases[x][y]+=offset[2]
                
        cases = [[15,0,0,15],
                 [13,0,0,15],
                 [11,0,0,7],
                 [15,0,0,15]]
        return cases

    def initgl(self):
        glClearColor(0,0,0,1)
        # generate a model  
        # set up the data

        gridSize = 4
        triSize = 2/gridSize

        
        cases = self.GetMachingCases()

        #marching squares 16 cases in triangle strips
        caseDict = {
            0:(),#nothing
            1:(0,0.5, 0,0, 0.5,0), #bottom left triangle
            2:(0.5,0, 1,0, 1,0.5),#bottom right triangle
            3:(0,0.5, 0,0, 1,0.5, 1,0),#bottom rectangle
            4:(),
            5:(),
            6:(),
            7:(),
            8:(),
            9:(0,1, 0,0, 0.5,1, 0.5,0),#left rectangle
            10:(), #top left to bottom right rectange
            11:(0,0, 0,1, 0.5,1, 1,0, 1,0.5,0,0,0,1),#empty top right
            12:(0,1, 0,0.5, 1,1, 1,0.5), # top rectangle
            13:(), #empty bottom cornor
            14:(),
            15:(0,1, 0,0, 1,1, 1,0)# full square
            }

        print(cases)
        self.vaos = []
        for x in range(gridSize):
            xPos = ((x/gridSize)-0.5)*2
            for y in range(gridSize):
                #add the square to the vertex buffer after finding all the points of the vertexes
                positions = []
                yPos = ((y/gridSize)-0.5)*2
                verts = caseDict[cases[x][y]]
                for i in range(len( verts)//2):
                    positions.append(xPos + verts[2*i] * triSize)
                    positions.append(yPos + verts[2*i+1] *triSize)
        
                positions = tuple(positions)

                

                self.triangles = len(positions)//2
                
                # apply the data  
                # generate a vertex array object so we can easily draw the resulting mesh later  
                vao = glGenVertexArrays(1)
                self.vaos.append(vao)
                # enable the vertex array before doing anything else, so anything we do is captured in the VAO context  
                glBindVertexArray(vao)  
                # generate 2 buffers, 1 for positions, 1 for elements. this is memory on the GPU that our model will be saved in.  
                bufs = glGenBuffers(1)  
                # set the first buffer for the main vertex data, that GL_ARRAY_BUFFER indicates that use case  
                glBindBuffer(GL_ARRAY_BUFFER, bufs)  
                # upload the position data to the GPU  
                # some info about the arguments:  
                # GL_ARRAY_BUFFER: this is the buffer we are uploading into, that is why we first had to bind the created buffer, else we'd be uploading to nothing  
                # sizeof(ctypes.c_float) * len(positions): openGL wants our data as raw C pointer, and for that it needs to know the size in bytes.  
                # the ctypes module helps us figure out the size in bytes of a single number, then we just multiply that by the array length  
                # (ctypes.c_float * len(positions))(*positions): this is a way to convert a python list or tuple to a ctypes array of the right data type  
                # internally this makes that data the right binary format  
                # GL_STATIC_DRAW: in OpenGL you can specify what you will be doing with this buffer, static means draw it a lot but never access or alter the data once uploaded.  
                # I suggest changing this only when hitting performance issues at a time you are doing way more complicated things. In general usage static is the fastest.  
                glBufferData(GL_ARRAY_BUFFER, sizeof(ctypes.c_float) * len(positions), (ctypes.c_float * len(positions))(*positions), GL_STATIC_DRAW)  
                # set the second buffer for the triangulation data, GL_ELEMENT_ARRAY_BUFFER indicates the use here  
                                # because the data is now on the GPU, our python positions & elements can be safely garbage collected hereafter  
                # turn on the position attribute so OpenGL starts using our array buffer to read vertex positions from  
                glEnableVertexAttribArray(0)  
                # set the dimensions of the position attribute, so it consumes 2 floats at a time (default is 4)  
                glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, None)



        
    def startgl(self):
        pass
    def redraw(self):
        glClear(GL_COLOR_BUFFER_BIT)

        for vao in self.vaos:
            glBindVertexArray(vao)
            glDrawArrays(GL_TRIANGLE_STRIP,0,self.triangles)





root = Tk()
root.geometry('500x500')
Renderer(root).pack(expand=1,fill='both')
root.mainloop()
